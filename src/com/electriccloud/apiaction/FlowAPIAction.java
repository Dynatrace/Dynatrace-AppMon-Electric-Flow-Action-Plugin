
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/




package com.electriccloud.apiaction;

import com.dynatrace.diagnostics.pdk.*;

import java.util.Collection;
import java.util.function.Supplier;
import java.util.logging.Logger;

import org.apache.http.*;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.AuthCache;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.*;

import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.BasicAuthCache;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.message.BasicNameValuePair;

import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.net.URLEncoder;
import java.security.KeyStore;
import java.util.ArrayList;
import java.util.List;


public class FlowAPIAction implements ActionV2 {
	private static final String CONFIG_HOST = "host";
	private static final String CONFIG_ENDPOINT = "endpoint";
	private static final String CONFIG_SCHEME = "scheme";
	private static final String CONFIG_PORT = "port";
	private static final String CONFIG_USERNAME = "username";
	private static final String CONFIG_PASSWORD = "password";
	private static final String CONFIG_ACTION_URL = "actionUrl";
	private static final String CONFIG_PARAMETERS = "parameters";
	private static final String CONFIG_METHOD = "method";
	private static final String CONFIG_BODY = "body";

	private static final Logger log = Logger.getLogger(FlowAPIAction.class.getName());

	private String host;
	private String scheme;
	private Long port;
	private String parameters;
	private String actionUrl;
	private String username;
	private String password;
	private String method;
	private String body;
	private String apiEndpoint;

	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * 
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link #teardown(ActionEnvironment)} will be called
	 * next.
	 * 
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>ActionEnvironment</tt> for this Plugin
	 * @see #teardown(ActionEnvironment)
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(ActionEnvironment env) throws Exception {
		apiEndpoint = env.getConfigString(CONFIG_ENDPOINT);
		String [] parts = apiEndpoint.split("(://|:)");

		scheme = parts[0];
		host = parts[1];
		port = Long.parseLong(parts[2]);

        parameters = env.getConfigString(CONFIG_PARAMETERS);

        actionUrl = env.getConfigString(CONFIG_ACTION_URL);
        username = env.getConfigString(CONFIG_USERNAME);
        if (username == null || username.equals("")) {
        	throw new RuntimeException("No username in config");
		}
        password = env.getConfigPassword(CONFIG_PASSWORD);
        if (password == null || password.equals("")) {
        	throw new RuntimeException("No password in config");
		}
		method = env.getConfigString(CONFIG_METHOD);
        if (method == null || method.equals("")) {
        	method = "POST";
		}
		body = env.getConfigString(CONFIG_BODY);

		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Action Plugin to process incidents.
	 * 
	 * <p>
	 * This method may be called at the scheduled intervals, but only if incidents
	 * occurred in the meantime. If the Plugin execution takes longer than the
	 * schedule interval, subsequent calls to
	 * {@link #execute(ActionEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link ActionEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link ActionEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 * 
	 * @param env
	 *            a <tt>ActionEnvironment</tt> object that contains the Plugin
	 *            configuration and incidents
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(ActionEnvironment env) throws Exception {

		Collection<Incident> incidents = env.getIncidents();
		for (Incident incident: incidents) {
		    String message = incident.getMessage();
            log.info("Incident " + message + " triggered.");
            for (Violation violation : incident.getViolations()) {
                log.info("Measure " + violation.getViolatedMeasure().getName() + " violoated threshold.");
            }
            callFlowAPI();
		}
        return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 * 
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 * 
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 * 
	 * @see #setup(ActionEnvironment)
	 */
	@Override
	public void teardown(ActionEnvironment env) throws Exception {
		// TODO
	}


	public void callFlowAPI() {

        String endpoint = this.apiEndpoint + "/rest/v1.0/";

        HttpHost targetHost = new HttpHost(host, port.intValue(), scheme);

        HttpClientBuilder cb = HttpClientBuilder.create().setHostnameVerifier(SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        SSLContextBuilder sslcb = new SSLContextBuilder();
        try {
            sslcb.loadTrustMaterial(KeyStore.getInstance(KeyStore.getDefaultType()), new TrustSelfSignedStrategy());
            cb.setSslcontext(sslcb.build());
        } catch (Throwable e) {
            log.info(e.getMessage());
            return;
        }
        log.info("API endpoint: " + endpoint);

        CloseableHttpClient httpclient = cb.build();
        CredentialsProvider credsProvider = new BasicCredentialsProvider();
        credsProvider.setCredentials(
                new AuthScope(targetHost.getHostName(), targetHost.getPort()),
                new UsernamePasswordCredentials(username, password));


        AuthCache authCache = new BasicAuthCache();
        BasicScheme basicAuth = new BasicScheme();
        authCache.put(targetHost, basicAuth);

        HttpClientContext context = HttpClientContext.create();
        context.setCredentialsProvider(credsProvider);
        context.setAuthCache(authCache);

        String apiUrl = endpoint + actionUrl;

        log.info("API url: " + apiUrl);
        log.info("Parameters: " + parameters);

        String query = "";
        if (parameters != null) {
			for (String pair : parameters.split("[\n\r]+")) {
				String[] keyValue = pair.split("\\s*=\\s*");
				log.info("key: " + keyValue[0]);
				log.info("Value: " + keyValue[1]);
				try {
					query += keyValue[0] + "=" + URLEncoder.encode(keyValue[1], "UTF-8") + "&";
				} catch (UnsupportedEncodingException e) {
					log.info(e.getMessage());
					return;
				}
			}
		}
        if (!query.equals("")) {
        	apiUrl += "?" + query;
		}
        HttpEntityEnclosingRequestBase request;
        if (method.equals("POST")) {
        	request = new HttpPost(apiUrl);
		}
		else if (method.equals("PUT")) {
        	request = new HttpPut(apiUrl);
		}
		else {
        	throw new RuntimeException("Unimpemented");
		}
		if ( body != null && !body.equals("") ) {
			StringEntity payload = new StringEntity(body, "UTF-8");
			payload.setContentType("application/json");
			request.setEntity(payload);
		}
		log.info(request.getRequestLine().toString());

        try {
            CloseableHttpResponse response = httpclient.execute(targetHost, request, context);
            try {
                String statusLine = response.getStatusLine().toString();
                log.info(statusLine);
            } finally {
                response.close();
            }
        } catch (Throwable e) {
            log.info(e.getMessage());
        }
    }

}
